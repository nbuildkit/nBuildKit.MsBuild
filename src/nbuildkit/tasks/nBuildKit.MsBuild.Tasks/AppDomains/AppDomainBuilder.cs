//-----------------------------------------------------------------------
// <copyright company="nBuildKit">
// Copyright (c) nBuildKit. All rights reserved.
// Licensed under the Apache License, Version 2.0 license. See LICENCE.md file in the project root for full license information.
// </copyright>
//-----------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Security.Permissions;

namespace NBuildKit.MsBuild.Tasks.AppDomains
{
    /// <summary>
    /// Builds AppDomains with unhandled exception handlers and fusion loading events.
    /// </summary>
    internal static partial class AppDomainBuilder
    {
        /// <summary>
        /// Returns the local file path from where a specific <see cref="Assembly"/>
        /// was loaded.
        /// </summary>
        /// <param name="assembly">The assembly.</param>
        /// <returns>
        /// The local file path from where the assembly was loaded.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        ///     Thrown if <paramref name="assembly"/> is <see langword="null" />.
        /// </exception>
        internal static string LocalFilePath(Assembly assembly)
        {
            if (assembly == null)
            {
                throw new ArgumentNullException(nameof(assembly));
            }

            // Get the location of the assembly before it was shadow-copied
            // Note that Assembly.Codebase gets the path to the manifest-containing
            // file, not necessarily the path to the file that contains a
            // specific type.
            var uncPath = new Uri(assembly.CodeBase);

            // Get the local path. This may not work if the assembly isn't
            // local. For now we assume it is.
            return uncPath.LocalPath;
        }

        /// <summary>
        /// A class used to attach an exception handler to the created domain.
        /// </summary>
        [SuppressMessage(
            "Performance",
            "CA1812:Avoid uninstantiated internal classes",
            Justification = "Used by instantiating via a type")]
        private sealed class ExceptionHandlerAttacher : MarshalByRefObject
        {
            /// <summary>
            /// Attaches the exception handler to the domain.
            /// </summary>
            [SuppressMessage(
                "Microsoft.Performance",
                "CA1822:MarkMembersAsStatic",
                Justification = "This needs to be called on a proxy so it can't be a static method.")]
            public void Attach()
            {
                var domain = AppDomain.CurrentDomain;
                var handler = new ExceptionHandler(null, null);
                domain.UnhandledException += (s, e) => handler.OnException(e.ExceptionObject as Exception);
            }
        }

        /// <summary>
        /// The default friendly name.
        /// </summary>
        private const string DefaultFriendlyName = "AppDomain generated by nBuildKit.MsBuild";

        /// <summary>
        /// Generates the new name of the app domain.
        /// </summary>
        /// <returns>The newly generated <c>AppDomain</c> name.</returns>
        [SuppressMessage(
            "Microsoft.Performance",
            "CA1811:AvoidUncalledPrivateCode",
            Justification = "This class is embedded in an user assembly and called from there. Hence all methods are internal.")]
        private static string GenerateNewAppDomainName()
        {
            return DefaultFriendlyName;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/>.
        /// </summary>
        /// <param name="name">The friendly name of the new <c>AppDomain</c>.</param>
        /// <param name="resolutionPaths">The assembly resolution paths for the new <c>AppDomain</c>.</param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        [SuppressMessage(
            "Microsoft.Performance",
            "CA1811:AvoidUncalledPrivateCode",
            Justification = "This class is embedded in an user assembly and called from there. Hence all methods are internal.")]
        private static AppDomain Create(string name, AppDomainResolutionPaths resolutionPaths)
        {
            {
                Debug.Assert(resolutionPaths != null, "The base path must be defined");
            }

            var setup = new AppDomainSetup
            {
                ApplicationName = Assembly.GetCallingAssembly().GetName().Name,
                ApplicationBase = resolutionPaths.BasePath,
                ShadowCopyFiles = "false",
                DisallowCodeDownload = true,
            };

            var result = AppDomain.CreateDomain(
                string.IsNullOrEmpty(name) ? GenerateNewAppDomainName() : name,
                null,
                setup);
            return result;
        }

        /// <summary>
        /// Creates a new <see cref="AppDomain"/> and attaches the assembly resolver and exception handlers.
        /// </summary>
        /// <param name="friendlyName">The friendly name of the new <c>AppDomain</c>.</param>
        /// <param name="resolutionPaths">The assembly resolution paths for the new <c>AppDomain</c>.</param>
        /// <returns>The newly created <c>AppDomain</c>.</returns>
        /// <exception cref="ArgumentNullException">
        ///     Thrown if <paramref name="resolutionPaths"/> is <see langword="null" />.
        /// </exception>
        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.ControlAppDomain)]
        [SuppressMessage(
            "Microsoft.Performance",
            "CA1811:AvoidUncalledPrivateCode",
            Justification = "This class is embedded in an user assembly and called from there. Hence all methods are internal.")]
        public static AppDomain Assemble(
            string friendlyName,
            AppDomainResolutionPaths resolutionPaths)
        {
            if (resolutionPaths == null)
            {
                throw new ArgumentNullException(nameof(resolutionPaths));
            }

            var domain = Create(friendlyName, resolutionPaths);

            // Attach to the assembly file resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection couldn't fill up later.
            if (resolutionPaths.Files != null)
            {
                var resolver = Activator.CreateInstanceFrom(
                    domain,
                    LocalFilePath(typeof(FileBasedResolver).Assembly),
                    typeof(FileBasedResolver).FullName).Unwrap() as FileBasedResolver;

                Debug.Assert(resolver != null, "Somehow we didn't create a resolver.");
                resolver.StoreFilePaths(resolutionPaths.Files);
                resolver.Attach();
            }

            // Attach to the assembly directory resolve event
            // We check for a null reference but not for an empty one,
            // there is after all no reason why the collection couldn't fill up later.
            if (resolutionPaths.Directories != null)
            {
                var resolver = Activator.CreateInstanceFrom(
                    domain,
                    LocalFilePath(typeof(DirectoryBasedResolver).Assembly),
                    typeof(DirectoryBasedResolver).FullName).Unwrap() as DirectoryBasedResolver;

                Debug.Assert(resolver != null, "Somehow we didn't create a resolver.");
                resolver.StoreDirectoryPaths(resolutionPaths.Directories);
                resolver.Attach();
            }

            // Attach the exception handler
            {
                var attacher = Activator.CreateInstanceFrom(
                    domain,
                    LocalFilePath(typeof(ExceptionHandlerAttacher).Assembly),
                    typeof(ExceptionHandlerAttacher).FullName).Unwrap() as ExceptionHandlerAttacher;

                Debug.Assert(attacher != null, "Somehow we didn't create an exception handler attacher.");
                attacher.Attach();
            }

            return domain;
        }
    }
}
